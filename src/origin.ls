import
  'livescript/lib/lexer': lexer
  'livescript/lib/parser': {parser}
  'livescript/lib/ast': ast
  'source-map': {SourceNode}

# Override Jison's default lexer, so that it can accept
# the generic stream of tokens our lexer produces.
parser <<<
  yy: ast
  lexer:
    lex: ->
      @pos = @pos + 1
      [tag, @yytext, first_line, first_column] = @tokens[@pos] or ['']
      [,, last_line, last_column] = @tokens[@pos+1] or ['']
      @yylineno = first_line
      @yylloc =
        first_line: first_line
        first_column: first_column
        last_line: last_line
        last_column: last_column
      tag
    set-input: ->
      @pos = -1
      @tokens = it
    upcoming-input: -> ''

lexer.lex.rewrite = lexer.rewrite

# Export AST constructors.
Object.assign ast, parser.yy

# Same as `tokens`, except that this skips rewriting.
function lex => lexer.lex it, {+raw}

# Parses a string or tokens of LiveScript code,
# returning the [AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree).
function ls-ast => parser.parse if typeof it is 'string' then lexer.lex it else it

function compile code, options = {}
  options.header ?= true
  try
    if options.json
      result = do Function exports.compile code, {+bare, +run, +print}
      "#{ JSON.stringify result, null, 2 }\n"
    else
      ast = parser.parse lexer.lex code
      ast.make-return! if options.run and options.print
      output = ast.compile-root options
      if options.header
        output = new SourceNode null, null, null, [
          "// Generated by LiveScript #{VERSION}\n", output
        ]
      if options.map and options.map isnt 'none'
        {filename, output-filename} = options
        unless filename
          filename = "unnamed-#{ Math.floor(Math.random! * 4294967296).to-string 16 }.ls"

        output.set-file filename
        result = output.to-string-with-source-map!
        if options.map is 'embedded'
          result.map.set-source-content filename, code
        if options.map in <[ linked debug ]>
          map-path = "#output-filename.map"
          result.code += "\n//# sourceMappingURL=#map-path\n"
        else
          result.code += "\n//# sourceMappingURL=data:application/json;base64,#{ new Buffer result.map.to-string! .to-string 'base64' }\n"
        result
      else
        output.to-string!
  catch
    e.message += "\nat #that" if options.filename
    throw e

VERSION = '1.5.0'
tokens = lexer.lex

export {
  VERSION
  # Tokenizes a string of LiveScript code, returning the array of tokens.
  tokens
  lex
  ast: ls-ast
  compile
}
